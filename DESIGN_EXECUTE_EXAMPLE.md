# Design 和 Execute 命令使用示例

这个文档展示了 `/design` 和 `/execute` 命令的典型使用场景。

## 场景1：添加新功能

### 使用 /design 命令

```
/design 为我的博客系统添加评论功能，需要支持嵌套回复和点赞
```

AI 助手会：
1. **分析现有代码**："我看到你的博客系统使用了 Next.js 和 PostgreSQL..."
2. **询问细节**：
   - "评论是否需要审核机制？"
   - "点赞是否需要登录？"
   - "嵌套回复的层级限制是多少？"
3. **确认技术方案**："基于你的需求，我建议使用递归查询处理嵌套评论..."
4. **生成设计文档**：在 `designs/` 目录创建详细的设计文档

### 使用 /execute 命令

设计确认后：
```
/execute
```

AI 助手会按照设计文档逐步实现功能。

## 场景2：重构现有代码

### 使用 /design 命令

```
/design 重构用户认证模块，从 session 改为 JWT token
```

AI 助手会：
1. **理解现状**：分析当前的 session 实现
2. **评估影响**：
   - "这会影响哪些 API 端点？"
   - "前端需要做哪些改动？"
3. **制定迁移计划**：包括数据迁移和兼容性考虑
4. **风险分析**：列出可能的问题和解决方案

## 场景3：修复复杂 Bug

### 使用 /design 命令

```
/design 修复用户上传大文件时内存溢出的问题
```

AI 助手会：
1. **定位问题**：分析当前的文件上传实现
2. **探讨方案**：
   - "是否考虑使用流式上传？"
   - "是否需要分片上传？"
3. **性能考虑**：讨论不同方案的性能影响
4. **测试策略**：如何验证修复效果

## 关键差异

### 与 /specify + /plan + /tasks 的区别

**传统流程**：
- `/specify`：创建功能规格
- `/plan`：生成技术方案
- `/tasks`：分解任务
- 整个过程较少交互，更多是单向生成

**新流程**：
- `/design`：**交互式**设计对齐，反复确认理解
- `/execute`：严格按照确认的设计执行
- 强调双向沟通和完全对齐

### 适用场景

**使用 /specify + /plan + /tasks**：
- 全新项目的快速搭建
- 明确的功能需求
- 标准化的实现方案

**使用 /design + /execute**：
- 复杂的重构任务
- 需要深入理解现有代码
- 有多种实现方案需要权衡
- Bug 修复需要全面分析
